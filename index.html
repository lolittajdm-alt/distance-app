<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Дистанция до объекта (камера + исправленный угол)</title>
<style>
  :root{--bg:#0f1115;--card:#161a22;--txt:#e9eef7;--mut:#9aa3b2;--acc:#3d7eff;--rad:14px}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font:16px ui-rounded,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:900px;margin:0 auto;padding:16px;display:grid;gap:16px}
  h1{margin:0;font-size:clamp(18px,5vw,22px)}
  .card{background:var(--card);border-radius:var(--rad);padding:14px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
  label{font-size:13px;color:var(--mut)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
  input,button{width:100%;border-radius:12px;border:1px solid #273041;background:#0e1218;color:var(--txt);padding:10px 12px;font-size:16px}
  button{background:var(--acc);border:none;font-weight:600;cursor:pointer}
  button.ghost{background:#1a2130;border:1px solid #2a3446}
  .metrics{display:flex;gap:10px;flex-wrap:wrap}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#1b2230;border:1px solid #2a3446;font-size:12px;color:var(--mut)}
  .big{font-size:clamp(18px,6vw,28px);font-weight:700}
  .view{position:relative;border-radius:12px;overflow:hidden;background:#000;height:52vh;min-height:260px}
  video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);}
  canvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Дистанция до точки на земле (камера+сенсоры)</h1>
    <div class="metrics">
      <span class="pill">Угол вниз α: <span id="ang">—</span>°</span>
      <span class="pill">Смещение нуля: <span id="off">0.0</span>°</span>
      <span class="pill">Сглажено N: <span id="n">—</span></span>
      <span class="pill">Инверсия pitch: <input id="invert" type="checkbox"/></span>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div>
        <label>Высота камеры над землёй, м</label>
        <input id="hCam" type="number" inputmode="decimal" step="0.01" value="1.60">
      </div>
      <div>
        <label>Перепад высот Δground = (цель − ты), м</label>
        <input id="dGround" type="number" inputmode="decimal" step="0.1" placeholder="напр. 2 или -3">
      </div>
    </div>
    <div class="row3" style="margin-top:10px">
      <button id="startCam" class="ghost">Start camera</button>
      <button id="start" class="ghost">Start sensors</button>
      <button id="calib">Калибровка горизонта</button>
    </div>
  </div>

  <div class="card view">
    <video id="vid" autoplay playsinline muted></video>
    <canvas id="ovr"></canvas>
  </div>

  <div class="card">
    <div class="big">Горизонтальная дальность D<sub>h</sub>: <span id="Dh">—</span></div>
    <div class="big">Наклонная дальность D<sub>s</sub>: <span id="Ds">—</span></div>
    <div class="big">Исп. Δground: <span id="dg">0.0</span> м</div>
    <div style="margin-top:10px" class="row3">
      <button id="measure">Замер</button>
      <button id="reset" class="ghost">Сбросить</button>
      <button id="freeze" class="ghost">Заморозить кадр</button>
    </div>
    <div style="margin-top:8px;color:#9aa3b2;font-size:13px">
      Наведи перекрестие на <b>основание</b> цели. Для дальних целей сделай 3–7 замеров — берётся среднее.
    </div>
  </div>
</div>

<script>
(function(){
  const $ = id => document.getElementById(id);
  const ui = { ang:$('ang'), off:$('off'), n:$('n'), Dh:$('Dh'), Ds:$('Ds'), dg:$('dg') };

  // ====== Камера ======
  const video = $('vid');
  const canvas = $('ovr');
  const ctx = canvas.getContext('2d');
  let frozen = false;

  $('startCam').addEventListener('click', async ()=>{
    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal:'environment' }, width:{ideal:1920}, height:{ideal:1080} },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      resize();
      window.addEventListener('resize', resize);
      requestAnimationFrame(drawOverlay);
      $('startCam').disabled = true;
    }catch(e){ alert('Нет доступа к камере: '+e); }
  });

  function resize(){
    const r = video.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(r.width * dpr);
    canvas.height = Math.round(r.height * dpr);
    canvas.style.width = r.width+'px';
    canvas.style.height = r.height+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function drawOverlay(){
    if (!frozen) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const cx = w/2, cy = h/2;
      ctx.strokeStyle = 'rgba(255,255,255,.85)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
      ctx.moveTo(0, cy); ctx.lineTo(w, cy);
      ctx.stroke();
      ctx.font = '14px system-ui, -apple-system';
      ctx.fillStyle = 'rgba(233,238,247,.9)';
      ctx.fillText('Наведи центр на основание цели', 12, 22);
    }
    requestAnimationFrame(drawOverlay);
  }

  $('freeze').addEventListener('click', ()=>{
    frozen = !frozen;
    $('freeze').textContent = frozen ? 'Разморозить кадр' : 'Заморозить кадр';
  });

  // ====== Сенсоры и расчёт ======
  let offsetDeg = 0;      // 0-уровень (горизонт)
  let alphaDownDeg = null; // угол НИЖЕ горизонта (то, что нам нужно)
  let invertPitch = false;
  let samplesH = [], samplesS = [];

  $('invert').addEventListener('change', e => invertPitch = e.target.checked);

  $('start').addEventListener('click', async ()=>{
    try{
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const p = await DeviceOrientationEvent.requestPermission();
        if (p !== 'granted') { alert('Доступ к датчикам отклонён.'); return; }
      }
      window.addEventListener('deviceorientation', handleOrientation, true);
      window.addEventListener('deviceorientationabsolute', handleOrientation, true);
      $('start').disabled = true;
    }catch(e){ alert('Ошибка доступа к датчикам: '+e); }
  });

  $('calib').addEventListener('click', ()=>{
    if (alphaDownDeg == null) { alert('Нет данных сенсоров. Нажми Start sensors.'); return; }
    offsetDeg = alphaDownDeg;
    ui.off.textContent = offsetDeg.toFixed(1);
    alert('Калибровка: текущий наклон принят за 0° (горизонт). Наводи на основание цели и меряй.');
  });

  $('measure').addEventListener('click', ()=>{
    const hCam = parseFloat($('hCam').value);
    const dGround = parseFloat($('dGround').value || '0');
    const avgN = clamp(1, 10, 5); // фикс. окно усреднения (можно сделать отдельное поле)

    if (!(hCam>0)) { alert('Укажи корректную высоту камеры (м).'); return; }
    if (alphaDownDeg == null) { alert('Нет данных сенсоров.'); return; }

    const alphaDeg = (alphaDownDeg - offsetDeg);
    const a = alphaDeg * Math.PI / 180;
    const deltaZ = hCam - dGround;

    const Dh = deltaZ / Math.tan(a);
    const Ds = deltaZ / Math.sin(a);

    if (!isFinite(Dh) || !isFinite(Ds) || Dh <= 0 || Ds <= 0) {
      alert('Похоже, геометрия противоречива. Проверь калибровку и знак Δground.');
      return;
    }

    samplesH.push(Dh); samplesS.push(Ds);
    while (samplesH.length > avgN) samplesH.shift();
    while (samplesS.length > avgN) samplesS.shift();

    ui.Dh.textContent = mean(samplesH).toFixed(2) + ' м';
    ui.Ds.textContent = mean(samplesS).toFixed(2) + ' м';
    ui.dg.textContent = dGround.toFixed(1) + ' м';
    ui.n.textContent  = String(samplesH.length);
  });

  $('reset').addEventListener('click', ()=>{
    samplesH=[]; samplesS=[];
    ui.Dh.textContent='—'; ui.Ds.textContent='—'; ui.n.textContent='—';
  });

  // ====== Правильный расчёт угла «вниз от горизонта» для любой ориентации ======
  function handleOrientation(e){
    // Углы устройства (W3C): alpha (Z), beta (X), gamma (Y)
    const α = (e.alpha ?? 0) * Math.PI/180;
    const β = (e.beta  ?? 0) * Math.PI/180;
    const γ = (e.gamma ?? 0) * Math.PI/180;

    // Угол поворота экрана (портрет/ландшафт)
    const scr = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
    const s = (scr || 0) * Math.PI/180;

    // Матрицы вращения
    const Rz = (a)=>[ [ Math.cos(a),-Math.sin(a),0],
                      [ Math.sin(a), Math.cos(a),0],
                      [ 0,0,1] ];
    const Rx = (a)=>[ [1,0,0],
                      [0, Math.cos(a),-Math.sin(a)],
                      [0, Math.sin(a), Math.cos(a)] ];
    const Ry = (a)=>[ [ Math.cos(a),0, Math.sin(a)],
                      [0,1,0],
                      [-Math.sin(a),0, Math.cos(a)] ];
    function mul(A,B){
      return [
        [A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0],
         A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1],
         A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]],
        [A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0],
         A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1],
         A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]],
        [A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0],
         A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1],
         A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]]
      ];
    }

    // Ротация устройства к миру (порядок W3C: Z * X' * Y'), плюс поворот экрана
    let R = mul(Rz(α), mul(Rx(β), mul(Ry(γ), Rz(s))));

    // Ось "вперёд" камеры — минус Z устройства, в мировых координатах:
    const f = { x: -R[0][2], y: -R[1][2], z: -R[2][2] };

    // Угол НИЖЕ горизонта: 0° на горизонте, +вниз, −вверх
    let aRad = Math.atan2( -f.z, Math.hypot(f.x, f.y) );
    if (invertPitch) aRad = -aRad;

    alphaDownDeg = aRad * 180/Math.PI;

    // Показать относительный калиброванный угол
    const alphaDisp = alphaDownDeg - offsetDeg;
    ui.ang.textContent = alphaDisp.toFixed(1);
  }

  // helpers
  function clamp(a,b,x){ return Math.max(a, Math.min(b,x)); }
  function mean(arr){ return arr.reduce((s,v)=>s+v,0)/arr.length; }
})();
</script>
</body>
</html>
